МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
  
КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ
 


 
Дисципліна «Аналіз та рефакторинг коду»
Звіт
з лабораторної роботи №4


 
 
   
Виконав:
ст. гр. ПЗПІ-23-5
Жилєнков А. О.


	 
	Перевірив:
ст. викладач кафедри ПІ
Сокорчук І. П.
 
	





Харків – 2025
1 ІСТОРІЯ ЗМІН
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	20.12.2025
	0.1
	Створено розділ «Завдання»
	2
	20.12.2025
	0.1
	Створено розділ «Опис Виконаної роботи»
	3
	20.12.2025
	0.1
	Створено розділ «Висновки»
	4
	20.12.2025
	0.1
	Створено розділ «Використані джерела»
	5
	20.12.2025
	0.1
	Створено розділ «Додаток А»
	6
	20.12.2025
	0.1
	Створено розділ «Додаток Б»
	7
	20.12.2025
	0.1
	Створено розділ «Додаток В»
	________________
2 ЗАВДАННЯ
Створення простого, але функціонального IoT-пристрою, який би працював у фоновому режимі, здійснював періодичну передачу даних на сервер і дозволяв адміністраторам системи отримувати інформацію про найбільш використовувані автомобілі. Для реалізації було обрано мову C#, що дозволило зберегти єдину технологічну стеку для всього проекту і уникнути використання додаткових технологій, забезпечивши максимальну простоту та зрозумілість коду.
________________


3 ОПИС ВИКОНАНОЇ РОБОТИ
Розробка почалася зі створення базового консольного застосунку, який виконував безперервний цикл роботи з інтервалом у десять секунд. Використання класу HttpClient забезпечило надійну та сучасну комунікацію між IoT-пристроєм та сервером через HTTP-протоколи. На початковому етапі пристрій надсилав лише сигнал про свою роботу, що дозволяло перевірити стабільність з’єднання, коректність URL-адрес та відсутність помилок у налаштуванні клієнтського запиту. Такий підхід забезпечив початкове тестування каналу зв’язку і дозволив впевнитися у правильності інтеграції з серверною частиною.
Після підтвердження стабільної роботи зв’язку було реалізовано обробку бізнес-логіки, пов’язаної з бронюванням автомобілів. IoT-пристрій отримує дані про бронювання за останній тридцятиденний період у вигляді JSON-об’єктів, які містять ідентифікатор автомобіля та дати початку і завершення оренди. На основі цих даних здійснюється розрахунок частоти бронювань кожного автомобіля у відсотках від загальної кількості днів періоду. Для цього спочатку групуються бронювання за автомобілями, потім обчислюється сумарна кількість днів бронювання для кожного транспортного засобу, після чого результат переводиться у відсотки і округлюється до двох знаків після коми. Такий підхід дозволяє виявити «проблемні» автомобілі, тобто ті, які використовуються найактивніше, що дає змогу адміністраторам планувати обслуговування, оптимізувати навантаження та приймати стратегічні рішення щодо управління автопарком.
Передача аналітики на сервер здійснюється у вигляді структурованих об’єктів, що включають ідентифікатор автомобіля та обчислену частоту бронювань. Для забезпечення надійності роботи пристрою було реалізовано обробку можливих помилок, пов’язаних із недоступністю сервера, неправильними URL або тимчасовими збоями мережі. У разі виникнення помилок програма не припиняє роботу, а виводить повідомлення про помилку у консоль і продовжує виконання циклу. Це забезпечує безперервність збору даних та стабільність функціонування IoT-пристрою в реальному середовищі.
Для перевірки коректності роботи IoT-пристрою було проведено серію тестових запусків, під час яких спостерігалася періодична відправка повідомлень у консоль з інформацією про успішне надсилання даних та результати розрахованої аналітики (див. додаток Б). Тести підтвердили правильність отримання, обробки та передачі даних, а також коректність розрахунків частоти бронювань.






________________


ВИСНОВКИ
У підсумку було створено IoT-пристрій, який ефективно інтегрується із системою AutoRent, виконує періодичне отримання та обробку даних про бронювання, проводить розрахунок частоти використання автомобілів, формує структуровані аналітичні об’єкти і передає їх на сервер. Розробка продемонструвала можливість реалізації IoT-рішення з мінімальною кількістю технологій та мов програмування, забезпечуючи надійність, стабільність роботи та корисну аналітику для прийняття управлінських рішень щодо автопарку.
________________
ВИКОРИСТАНІ ДЖЕРЕЛА
1. Microsoft Corporation. ASP.NET Core — офіційна документація [Електронний ресурс]. — Посилання: https://learn.microsoft.com/aspnet/core (дата звернення: 20.12.2025).
2. Microsoft SQL Server — офіційна документація [Електронний ресурс]. — Посилання: https://learn.microsoft.com/sql (дата звернення: 20.12.2025).
3. Microsoft Corporation. Entity Framework Core — офіційна документація [Електронний ресурс]. — Посилання: https://learn.microsoft.com/ef/core (дата звернення: 20.12.2025).




________________


ДОДАТОК А
Відеозапис
Відеозапис презентації результатів лабораторної роботи: https://youtu.be/mJUG5bht5EI
Хронологічний опис відеозапису
00:21 — IoTController.cs
02:01 — IoTDevice
03:08 — Demo
________________
ДОДАТОК Б
Графічні матеріали


  Рисунок Б.1 — Виведення в консоль IoT-застосунку


  
Рисунок Б.2 — Виведення в консоль сервера AutoRent
________________
ДОДАТОК В
Програмний код
Посилання на Github: https://github.com/NureZhylienkovAndrii/ark-pzpi-23-5-zhylienkov-andrii/tree/main/Lab4
В.1 IoTController.cs
1  using AutoRent.Data;
2  using Microsoft.AspNetCore.Mvc;
3  using Microsoft.EntityFrameworkCore;
4  
5  namespace AutoRent.Controllers
6  {
7      [ApiController]
8      [Route("api/iot")]
9      public class IoTController : ControllerBase
10     {
11         private readonly AppDbContext _db;
12 
13         public IoTController(AppDbContext db)
14         {
15             _db = db;
16         }
17 
18         [HttpGet("bookings")]
19         public async Task<IActionResult> GetBookings([FromQuery] int days = 30)
20         {
21             var fromDate = DateTime.Now.AddDays(-days);
22 
23             var bookings = await _db.Bookings
24                 .Where(b => b.Status != "Cancelled" && b.StartDate >= fromDate)
25                 .Select(b => new
26                 {
27                     b.CarId,
28                     b.StartDate,
29                     b.EndDate
30                 })
31                 .ToListAsync();
32 
33             return Ok(bookings);
34         }
35 
36         [HttpPost("analytics")]
37         public IActionResult ReceiveAnalytics([FromBody] List<CarBookingStatDto> stats)
38         {
39             Console.WriteLine("IoT analytics received");
40 
41             foreach (var stat in stats)
42             {
43                 Console.WriteLine(
44                     $"Car {stat.CarId} — booking frequency {stat.BookingFrequencyPercent}%");
45             }
46 
47             return Ok();
48         }
49     }
50 
51     public record CarBookingStatDto
52     (
53         int CarId,
54         double BookingFrequencyPercent
55     );
56 }


В.2 AutoRent.IoTDevice
1   using System.Net.Http;
2   using System.Net.Http.Json;
3
4   Console.WriteLine("IoT device started...");
5
6   var httpClient = new HttpClient
7   {
8       BaseAddress = new Uri("https://localhost:7048")
9   };
10
11  const int periodDays = 30;
12
13  while (true)
14  {
15      try
16      {
17          var bookings = await httpClient
18              .GetFromJsonAsync<List<BookingDto>>("/api/iot/bookings?days=30");
19
20          if (bookings == null || bookings.Count == 0)
21          {
22              Console.WriteLine("No bookings data received");
23              await Task.Delay(10000);
24              continue;
25          }
26
27          var stats = bookings
28              .GroupBy(b => b.CarId)
29              .Select(group =>
30              {
31                  var bookedDays = group.Sum(b =>
32                      (b.EndDate.Date - b.StartDate.Date).Days);
33
34                  var frequency = Math.Round(
35                      (double)bookedDays / periodDays * 100, 2);
36
37                  return new CarBookingStat(group.Key, frequency);
38              })
39              .OrderByDescending(s => s.BookingFrequencyPercent)
40              .ToList();
41
42          var response = await httpClient
43              .PostAsJsonAsync("/api/iot/analytics", stats);
44
45          if (response.IsSuccessStatusCode)
46          {
47              Console.WriteLine($"[{DateTime.Now}] Analytics sent:");
48              foreach (var stat in stats)
49              {
50                  Console.WriteLine(
51                      $"Car {stat.CarId}: {stat.BookingFrequencyPercent}%");
52              }
53          }
54          else
55          {
56              Console.WriteLine($"Error sending analytics: {response.StatusCode}");
57          }
58      }
59      catch (Exception ex)
60      {
61          Console.WriteLine($"IoT error: {ex.Message}");
62      }
63
64      await Task.Delay(10000);
65  }
66
67  record BookingDto(int CarId, DateTime StartDate, DateTime EndDate);
68
69  record CarBookingStat
70  (
71      int CarId,
72      double BookingFrequencyPercent
73  );