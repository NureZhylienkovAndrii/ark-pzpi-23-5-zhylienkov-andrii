МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
  
КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ
 


 
Дисципліна «Аналіз та рефакторинг коду»
Звіт
з практичної роботи №1


 
 
   
Виконав:
ст. гр. ПЗПІ-23-5
Жилєнков А. О.


	 
	Перевірив:
ст. викладач кафедри ПІ
Сокорчук І. П.
 
	





Харків – 2025
1 ІСТОРІЯ ЗМІН
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	09.10.2025
	0.1
	Створено розділ «Завдання»
	2
	09.10.2025
	0.1
	Створено розділ «Опис Виконаної роботи»
	3
	09.10.2025
	0.1
	Створено розділ «Висновки»
	4
	09.10.2025
	0.1
	Створено розділ «Використані джерела»
	5
	09.10.2025
	0.1
	Створено розділ «Додаток А»
	6
	09.10.2025
	0.1
	Створено розділ «Додаток Б»
	7
	09.10.2025
	0.1
	Створено розділ «Додаток В»
	________________
2 ЗАВДАННЯ
Завданням цієї практичної роботи є дослідження правил оформлення коду для мови програмування Rust та обґрунтування важливості їх застосування в процесі розробки програмного забезпечення. Завдання полягало у вивченні офіційних рекомендацій спільноти розробників Rust, що стосуються стилю написання коду, а також у демонстрації практичного застосування цих правил на конкретних прикладах. У межах роботи потрібно проаналізувати структурування проєкту відповідно до прийнятих стандартів, особливості форматування коду та використання інструментів автоматизації для підтримки єдиного стилю.
________________


3 ОПИС ВИКОНАНОЇ РОБОТИ
У ході виконання роботи було опрацьовано офіційні рекомендації спільноти розробників мови програмування Rust, зокрема положення, викладені в «The Rust Style Guide» [1], «Rust API Guidelines» [2] та документації інструментів Rustfmt і Clippy [3]. На основі цих джерел здійснено систематизацію правил оформлення коду та розроблено логічну структуру викладення матеріалу, яка охоплює ключові аспекти чистого та підтримуваного програмного коду.
На початковому етапі було розглянуто структурування Rust-проєкту відповідно до загальноприйнятих принципів. Було визначено роль файлів src/main.rs як точки входу для виконуваних програм та src/lib.rs як базового файлу бібліотеки. Окремо проаналізовано механізми розподілу коду на модулі за допомогою ключових слів mod, use та pub, що забезпечують логічну організацію проєкту та контроль доступності елементів.
Наступним етапом стало дослідження стандартів форматування коду. Було розглянуто правила використання відступів, вирівнювання та обмеження довжини рядків, а також стилі розташування фігурних дужок. Особлива увага приділялася використанню інструменту rustfmt, який забезпечує автоматичне вирівнювання коду відповідно до офіційних вимог.
У подальшій частині роботи були опрацьовані правила іменування елементів програми. Зокрема, проаналізовано використання стилю snake_case для змінних та функцій, CamelCase для структур, типів і перерахувань, а також SCREAMING_SNAKE_CASE для констант. Пояснено, як правильне іменування підвищує читабельність і зменшує ризик помилок у командній роботі.
В окремому розділі було розглянуто призначення та правильне використання коментарів у коді. Було визначено різницю між коментарями, що пояснюють логіку реалізації, та коментарями, які описують технічні деталі. Також вивчено синтаксис однорядкових та багаторядкових коментарів і правила уникнення надлишкових пояснень у коді, який уже є самодокументованим.
Далі було досліджено механізми документування в Rust за допомогою спеціалізованого синтаксису /// та //!. На прикладі функцій продемонстровано, як за допомогою коментарів з розділами # Arguments та # Returns можна автоматично формувати зрозумілу документацію через cargo doc. Це сприяє кращій структурованості та прозорості програмного забезпечення.
Крім цього, у процесі роботи було вивчено роль інструментів clippy і rustfmt для перевірки якості коду та підтримки єдиного стилю. Вони дозволяють виявляти стильові та логічні помилки ще до етапу тестування й забезпечують єдність стилю між різними розробниками.
Окремо було розглянуто принципи розробки на основі тестування (TDD) з використанням атрибутів #[test] та #[cfg(test)], що дозволяє інтегрувати модульні тести безпосередньо в код. Пояснено, як така практика сприяє підвищенню надійності програмного забезпечення та полегшує його подальшу підтримку.
Завершальним етапом стало порівняння прикладів погано та добре оформленого коду на Rust. У першому випадку продемонстровано відсутність відступів, хаотичне іменування та низьку читабельність. У другому прикладі показано впорядкований код з чітким форматуванням, коментарями та зрозумілими іменами, що відображає дотримання офіційних стандартів мови.






________________


ВИСНОВКИ
У ході виконання роботи було встановлено, що дотримання офіційних правил оформлення коду в мові Rust суттєво підвищує якість програмного забезпечення. Єдиний стиль коду забезпечує його читабельність, полегшує командну взаємодію та зменшує ризик помилок. Використання модульної структури проєкту та інструментів автоматизації, таких як rustfmt і Clippy, дає змогу підтримувати впорядкованість коду та швидко виявляти недоліки. Правильне іменування елементів, лаконічні коментарі та автоматично згенерована документація підвищують зрозумілість і спрощують подальшу підтримку проєкту. Застосування принципів TDD у поєднанні з дотриманням стильових рекомендацій сприяє створенню більш стабільних і надійних програмних рішень. Порівняння прикладів продемонструвало, що чистий і структурований код значно легше розвивати й підтримувати.
________________
ВИКОРИСТАНІ ДЖЕРЕЛА
1. Rust Project Developers. The Rust Style Guide [Електронний ресурс]
Rust Foundation. — 2025. — Посилання: https://doc.rust-lang.org/nightly/style-guide/ (дата звернення: 09.10.2025).
2. Rust Project Developers. Naming — Rust API Guidelines [Електронний ресурс] / Rust Foundation. — 2025. — Посилання: https://rust-lang.github.io/api-guidelines/naming.html (дата звернення: 09.10.2025).
3. Rust Project Developers. Rustfmt Guide [Електронний ресурс] / Rust Foundation. — 2025. — Посилання: https://rust-lang.github.io/rustfmt/ (дата звернення: 09.10.2025).


________________


ДОДАТОК А
Відеозапис
Відеозапис презентації результатів лабораторної роботи: https://youtu.be/QjOLhcJ5Bk0
Хронологічний опис відеозапису
00:00 — Вступ
00:35 — Структура коду
01:13 — Форматування коду
02:04 — Іменування
02:36 — Коментарі
02:55 — Документування коду
03:25 — Конвенції стилю кодування
04:02 — Кодування на основі тестування
04:41 — Інструменти та автоматизація
05:19 — Приклади оформлення коду
06:05 — Висновки
________________
ДОДАТОК Б
Графічні матеріали
  Рисунок Б.1 — Вступ
  
Рисунок Б.2 — Структура коду
  Рисунок Б.3 — Форматування коду
  Рисунок Б.4 — Іменування
  Рисунок Б.5 — Коментарі
  Рисунок Б.6 — Документування коду
  Рисунок Б.7 — Конвенції стилю кодування
  Рисунок Б.8 — Кодування на основі тестування
  Рисунок Б.9 — Інструменти та автоматизація
  Рисунок Б.10 — Приклади оформлення коду
  Рисунок Б.11 — Висновки
  Рисунок Б.12 — Джерела
________________
ДОДАТОК В
Програмний код
В.1 Приклад структури коду
1 // src/lib.rs
2 pub mod math;
3 pub mod utils;
4 
5 // src/math.rs
6 pub fn add(a: i32, b: i32) -> i32 {
7     a + b
8 }
В.2 Приклад поганого форматування коду
 fn add(a:i32,b:i32)->i32{a+b}


В.3 Приклад гарного форматування коду
1 fn add(a: i32, b: i32) -> i32 {
2     a + b
3 }
В.4 Приклад іменування
 1 const MAX_USERS: u32 = 100;
 2  
 3 struct UserProfile {
 4     username: String,
 5     age: u8,
 6 }
 7  
 8 fn get_user_name(user: &UserProfile) -> &str {
 9     &user.username
10 }
В.5 Приклад документування коду
 1 /// Додає два числа
 2 ///
 3 /// # Arguments
 4 /// * `a` - перше число
 5 /// * `b` - друге число
 6 ///
 7 /// # Returns
 8 /// Суму чисел `a` та `b`
 9 
10 fn add(a: i32, b: i32) -> i32 {
11     a + b
12 }
В.6 Приклад тесту
1 #[cfg(test)]
2 mod tests {
3     use super::*;
4
5     #[test]
6     fn test_add() {
7         assert_eq!(add(2, 3), 5);
8     }
9 }
В.7 Поганий приклад оформлення коду
1 fn f(a:i32,b:i32)->i32{let mut c=0;for i in 0..a{c+=b}c}
2 fn main(){println!("Result: {}",f(5,3));}
В.7 Хороший приклад оформлення коду
 1 fn multiply_by_repeated_addition(a: i32, b: i32) -> i32 {
 2     let mut result = 0;
 3     for _ in 0..a {
 4         result += b;
 5     }
 6     result
 7 }
 8
 9 fn main() {
10     let a = 5;
11     let b = 3;
12     let result = multiply_by_repeated_addition(a, b);
13     println!("Result: {}", result);
14 }
