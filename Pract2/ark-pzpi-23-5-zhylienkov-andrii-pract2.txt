МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
 
  
КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ
 


 
Дисципліна «Аналіз та рефакторинг коду»
Звіт
з практичної роботи №2


 
 
   
Виконав:
ст. гр. ПЗПІ-23-5
Жилєнков А. О.


	 
	Перевірив:
ст. викладач кафедри ПІ
Сокорчук І. П.
 
	





Харків – 2025
1 ІСТОРІЯ ЗМІН
№
	Дата
	Версія звіту
	Опис змін та виправлень
	1
	23.10.2025
	0.1
	Створено розділ «Завдання»
	2
	23.10.2025
	0.1
	Створено розділ «Опис Виконаної роботи»
	3
	23.10.2025
	0.1
	Створено розділ «Висновки»
	4
	23.10.2025
	0.1
	Створено розділ «Використані джерела»
	5
	23.10.2025
	0.1
	Створено розділ «Додаток А»
	6
	23.10.2025
	0.1
	Створено розділ «Додаток Б»
	7
	23.10.2025
	0.1
	Створено розділ «Додаток В»
	________________
2 ЗАВДАННЯ
Метою роботи було дослідити та продемонструвати практичне застосування трьох методів рефакторингу, описаних Р. Мартіном у книзі «Чистий код», у контексті об’єктно-орієнтованого програмування мовою Java. Завданням студента було підготувати теоретичний опис методів, проілюструвати їх практичними прикладами коду до та після рефакторингу, а також показати вплив кожного з них на структуру програмного забезпечення.
________________


3 ОПИС ВИКОНАНОЇ РОБОТИ
У процесі виконання практичної роботи було проведено системний аналіз принципів рефакторингу, сформульованих у книзі Роберта Мартіна «Чистий код: створення, аналіз та рефакторинг за допомогою Agile»[1]. Основна увага була зосереджена на трьох конкретних методах — Replace Type Code with Subclasses, Replace Parameter with Method та Duplicate Observed Data, — що демонструють різні аспекти вдосконалення архітектури програмних систем. Робота мала на меті не лише продемонструвати теоретичні засади цих технік, а й показати їхнє практичне застосування в об’єктно-орієнтованому середовищі програмування мовою Java.
На першому етапі було здійснено підготовку вихідних прикладів програмного коду, які містили типові порушення принципів чистої архітектури. Зокрема, у вихідному коді застосовувався підхід, заснований на використанні кодів типів (числових або символьних констант), що призводило до громіздких конструкцій switch та дублювання логіки в межах класів. Для усунення цієї проблеми був реалізований метод Replace Type Code with Subclasses, який полягає у створенні ієрархії підкласів, кожен з яких реалізує специфічну поведінку. Завдяки цьому код став більш модульним, відкритим до розширення й закритим до змін відповідно до принципу Open/Closed. У прикладі з класом Employee заміна умовних операторів на поліморфізм дозволила усунути складну розгалужену логіку та підвищити гнучкість системи при додаванні нових типів співробітників.
Далі було проаналізовано метод Replace Parameter with Method, який усуває надлишкові параметри з інтерфейсу класу. У вихідному прикладі метод format(boolean compact) мав параметр, що визначав формат виведення звіту. Така реалізація порушувала принцип єдиної відповідальності та ускладнювала підтримку коду. У результаті рефакторингу метод було розділено на два окремі — formatCompact() та formatDetailed(), — кожен із яких реалізує чітко визначену функцію. Це дозволило підвищити зрозумілість викликів, спростити тестування та уникнути потенційних помилок при неправильному переданні параметрів. Розділення поведінки на окремі методи також сприяє легшій подальшій інтеграції з іншими компонентами програми.
Третім етапом стало впровадження методу Duplicate Observed Data, який вирішує проблему дублювання даних між кількома класами. У початковій реалізації класи Invoice та Order містили ідентичне поле taxRate, що призводило до ризику розсинхронізації значень у різних частинах програми. Рефакторинг передбачав створення окремого об’єкта TaxPolicy, який став єдиним джерелом даних для розрахунку податкових ставок. Такий підхід забезпечив централізоване управління конфігурацією, підвищив узгодженість системи та зменшив обсяг дубльованого коду. Результатом стала більша гнучкість у зміні бізнес-логіки, оскільки зміни податкової політики тепер вносяться лише в одному місці.
Після виконання індивідуальних прикладів усі три методи було об’єднано в одному інтегрованому прикладі класу EmployeeRecord, що демонструє їхню сумісність у реальних умовах програмної розробки. Було показано, що застосування цих технік дозволяє підвищити зв’язність і зменшити кількість залежностей між компонентами системи. Рефакторинг проводився з дотриманням дисципліни малих, контрольованих змін і з постійним тестуванням після кожного етапу, що відповідає принципам Agile-розробки.
У межах роботи також було здійснено огляд сучасних інструментів підтримки рефакторингу. Зокрема, розглянуто можливості інтегрованих середовищ розробки IntelliJ IDEA[2], Visual Studio[3] та Eclipse[4], які автоматизують операції з перейменування, виділення методів, переміщення полів і класів, а також виявлення дублікатів коду. Використання цих інструментів дозволяє розробнику зосередитися на логіці та архітектурі, зменшуючи ризик технічних помилок.










________________


ВИСНОВКИ
У ході виконання практичної роботи було доведено, що системний рефакторинг є невід’ємною складовою життєвого циклу програмного забезпечення, спрямованою на підтримку його якості та гнучкості. Застосування методів Replace Type Code with Subclasses, Replace Parameter with Method та Duplicate Observed Data у Java-проєктах дозволяє зменшити когнітивну складність коду, усунути дублювання логіки, підвищити рівень повторного використання компонентів і забезпечити стійкість архітектури до змін. Практичні результати підтвердили, що навіть локальні зміни, виконані у відповідності до принципів рефакторингу, мають суттєвий вплив на зрозумілість, тестованість та підтримуваність програмних систем.
________________
ВИКОРИСТАНІ ДЖЕРЕЛА
1. Мартін, Р. Чистий код: створення, аналіз та рефакторинг за допомогою Agile / Р. Мартін ; пер. з англ. — Харків : Фабула, 2019. — 416 с.
2. JetBrains s.r.o. IntelliJ IDEA — офіційна документація [Електронний ресурс]. — Посилання: https://www.jetbrains.com/idea/documentation/ (дата звернення: 24.10.2025).
3. Microsoft Corporation. Visual Studio — офіційна документація [Електронний ресурс]. — Посилання: https://learn.microsoft.com/visualstudio (дата звернення: 24.10.2025).
4. Eclipse Foundation. Eclipse IDE — офіційна документація [Електронний ресурс]. — Посилання: https://help.eclipse.org (дата звернення: 24.10.2025).




________________


ДОДАТОК А
Відеозапис
Відеозапис презентації результатів лабораторної роботи: https://youtu.be/UKRtpQ6NlAE
Хронологічний опис відеозапису
00:26 — Вступ
00:56 — Методи, розглянуті в доповіді
01:31 — Replace type code with subclasses
02:13 — Приклад коду до та після першого методу
03:02 — Replace Parameter with Method
03:38 — Приклади коду до та після другого методу
04:11 — Duplicate Observed Data
04:49 — Приклади коду до та після третього методу
05:20 — Загальний приклад коду до рефакторингу
05:41 — Приклад коду після застосування трьох методів
06:14 — Покрокова стратегія рефакторингу
06:53 — Інструменти для рефакторингу
07:28 — Висновки
________________
ДОДАТОК Б
Графічні матеріали
  Рисунок Б.1 — Титульний слайд
  
Рисунок Б.2 — Вступ
  Рисунок Б.3 — Методи, розглянуті в доповіді
  Рисунок Б.4 — Replace type code with subclasses
  Рисунок Б.5 — Приклад коду до та після першого методу
  Рисунок Б.6 — Replace Parameter with Method
  Рисунок Б.7 — Приклади коду до та після другого методу
  Рисунок Б.8 — Duplicate Observed Data
  Рисунок Б.9 — Приклади коду до та після третього методу
  Рисунок Б.10 — Загальний приклад коду до рефакторингу
  Рисунок Б.11 — Приклад коду після застосування трьох методів
  Рисунок Б.12 — Покрокова стратегія рефакторингу
  Рисунок Б.13 — Інструменти для рефакторингу
  Рисунок Б.14 — Висновки
  Рисунок Б.15 — Джерела
________________
ДОДАТОК В
Програмний код
В.1 Приклад коду до першого методу
1  class Employee {
2      public static final int ENGINEER = 0;
3      private int type;
4      double payAmount() {
5          switch(type) {
6              case ENGINEER: return salary;
7              case 1: return salary + commission;
8              default: return salary + bonus;
9          }
10     }
11 }


В.2 Приклад коду після першого методу
1  abstract class Employee {
2      abstract double payAmount();
3  }
4  
5  class Engineer extends Employee {
6      double payAmount() { return salary; }
7  }
8  
9  class Salesman extends Employee {
10     double payAmount() { return salary + commission; }
11 }


В.3 Приклад коду до другого методу
1  class Report {
2    String format(boolean compact) {
3      if (compact) return "Compact";
4      else return "Detailed";
5    }
6  }


В.4 Приклад коду після другого методу
1  class Report {
2    String formatCompact() {
3      return "Compact";
4    }
5    String formatDetailed() {
6      return "Detailed";
7    }
8  }


В.5 Приклад коду до третього методу
1  class Invoice {
2      double taxRate = 0.2;
3      double total(double net) { return net * (1 + taxRate); }
4  }
5  
6  class Order {
7      double taxRate = 0.2;
8      double total(double net) { return net * (1 + taxRate); }
9  }


В.6 Приклад коду після третього методу
1  class TaxPolicy {
2      double taxRate = 0.2;
3      double apply(double net) { return net * (1 + taxRate); }
4  }
5  
6  class Invoice {
7      TaxPolicy tax;
8      double total(double net) { return tax.apply(net); }
9  }


В.7 Загальний приклад коду до рефакторингу
1  class EmployeeRecord {
2      int type;
3      boolean compactReport;
4      double taxRate = 0.2;
5
6      double pay() { /* switch */ }
7      String report(boolean compact) { /* if-else */ }
8      double total(double net) { return net * (1 + taxRate); }
9  }


В.7 Загальний приклад коду після рефакторингу
1  abstract class Employee {
2      TaxPolicy tax;
3      abstract double pay();
4      String reportCompact(){ ... }
5      String reportDetailed(){ ... }
6  }
7  class Engineer extends Employee {
8      double pay(){ return ...; }
9  }